学习笔记
- Trie树
1. 应用于统计和排序大量的字符，判断前缀字符或字符是否存在
2. 基本操作： insert(s)、search(s)、searchPrefix(s) 
3. 字典树的节点与一般树不同，节点内部不存整个数据，而是把字符串拆成单个单个char，存放在各个节点中
4. 为多叉树，若为表示a-z的则是26叉树
5. 需记熟代码模版

- 并查集
1. 目的为判断两个集体是不是在同一个集合当中
2. 基本操作： makeSet(s)、unionSet(s)t、find(x)
3. 需记熟代码模版

- 高级搜索
1. 优化方式：不重复：缓存计算结果；减支：将状态树中重复或者次优的分支减掉
2. 搜索方向：双向搜索、启发式搜索
3. 双向搜索：从头、尾同时进行BFS，双边在中间相遇
4. 启发式搜索：基于BFS，使用优先队列取代队列，并且根据估价函数对节点进行评价，若节点能让答案更优对则优先度更高
5. 二维矩阵使用曼哈顿距离作为估价函数
6. 所谓的搜索问题，其实就是在它整个状态树里面，做深度优先、广度优先、优先级优先搜索，最后找到要的比如说最优解，或者统计它的分支个数
7. 在做搜索问题时，需要联想到该问题对状态树


- AVL Tree与红黑树
1. 树与链表没有本质区别，当一个链表裂出两个next时，就称为树；本质就是从一维空间变成二维空间，二叉搜索树的查询插入和搜索可以从链表的O(n)降低为O(logN)
2. 在插入二叉搜索树的极端情况下，会变成一根棍子，插入、查找的复杂度退化成链表的O(N)，所以引入平衡二叉树的概念
3. 平衡二叉树会在每一步进行插入或删除操作的时候，都去判断它是否平衡，以及将它维护成平衡二叉树的状态
4. 为什么使用树的高度来衡量是否平衡：因为查询二叉树查询效率只与高度有关，和树的节点的个数无关
5. 所有的叶子节点的平衡因子都是0
6. AVL tree也是二叉搜索树，所以插入时，也先执行与二叉搜索树相同的步骤，找到适当的插入位置，然后判断平衡因子是否符合阀值，若否，则进行旋转调整
7. 旋转操作：本质上就是左、右旋；左右旋、右左旋是基础旋转的搭配，只是有些数字结构要旋转两次，就是不平衡的部分出现勾状
8. 不足：需要额外存储信息，每个节点都需要额外int的平衡因子信息；平衡因子相对严格，导致可能插入1～2次就有进行维持平衡的操作
9. 红黑树特性：每个节点非红即黑；根节点、叶子节点为黑、不能连续两个红节点、从任一节点到其叶子节点对所有路径包含相同数量的黑色节点
10. 红黑树是近似平衡树，不需要每次进行平衡操作，提高效率
11. 从读、查找的性能来说，AVL tree的性能较好，因为它是严格平衡的
12. 红黑树提供较快的插入、删除操作，因为AVL的旋转次数会更多，红黑树会相对少一点，因为其是一个近似平衡树
13. AVL tree需要额外的空间来存储factor or hight，附加在每个节点里面来存这些额外的信息，而红黑树只需要额外的1 bit来存表示红或者黑，所以对额外空间的消耗更少
14. 在读操作非常多，写操作很少的时候，使用AVL tree，AVL的问题就是插入删除调整得比较频繁，好处则是非常平衡，所以查询很快
15. 若插入删除比较多，或者插入和查询操作一半一半的话，一般使用红黑树，因为红黑树比较简洁额，比较好实现

