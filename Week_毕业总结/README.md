学习笔记
### 基本数据结构
- Array
  - 插入/删除: O(N)
  - 查询: O(1)
- List
  - 插入/删除: O(N)
  - 查询: O(N)

### 高级数据结构
- Skip List
  - 为了改进List的查询时间复杂度为O(LogN)
  - 牺牲空间复杂度为O(N)
  - 牺牲插入/删除的时间复杂度为O(LogN)
  - 对比平衡树
- Stack
  - FILO
  - 关联算法: 递归、回溯
  - 插入/删除: O(1)
  - 查询: O(N)
- Queue
  - FIFO
  - 关联算法: BFS、滑动窗口
  - 插入/删除: O(1)
  - 查询: O(N)
- Deque
  - 双端队列
  - 工程中使用来模拟Stack、Queue
- Priority Queue
  - 优先级元素排序功能
  - 关联算法: 大顶堆、小顶堆的TopK、A* search
- Tree
  - 前、中、后序
  - 查询: O(N)
  - 关联算法: 回溯、贪婪、动态规划中的状态树
- Binary Search Tree
  - 为了改善Tree的查询效率为O(LogN)
- AVL Tree
  - 为了改善Binary Search Tree在极端情况下变成List导致查询的时间复杂度变成O(N)
  - 每次新增、删除操作后，平衡因子维持在-1, 0, -1
  - 背好旋转操作
- Red-black Tree
  - 近似平衡二叉树，为了改善AVL Tree的频繁旋转操作导致的效能降低
  - 每次新增、删除操作后，保证左、右子树的高度差在2倍内
  - 读多写少时使用AVL Tree，写多或插入、查询操作各占一半时用Red-black Tree
- Heap
  - 大顶堆、小顶堆
  - 查找max: O(1)
  - 删除max: O(LogN)
  - 插入: O(LogN)、O(1)
  - 有很多种实现，不一定是二叉堆
- Graph
  - 关联算法: DFS、BFS
- Trie Tree
  - 用于查找前缀词或者公共前缀
  - 插入: O(m)
  - 查找: O(m)
  - 把代码背好
- 并查集
  - 用于组团、配对问题
  - 把代码背好

### 算法
- 递归
  - 把代码模版背好
- 分治/回溯
  - 分治/回溯本质上就是递归
  - 把代码模版背好
- BFS/DFS
  - 把代码模版背好
- 贪心算法
  - 在每一步选择最优解以达成全局最优
  - 贪心算法无法回退，是回溯才可以回退
  - 把代码模版背好
- 二分查找
  - 数据为有序时，才可以使用
  - 把代码模版背好
- 动态规划
  - 最优子结构 + 状态 + 递推公司
  - 状态一维不能表达，可以考虑二维、三维
  - 多刷题 
- A* Search
  - 基于BFS，但使用Priority Queue进行智能判断

### 其他
- 位运算
  - 准备好算法题常用技巧
- 布隆过滤器
  - Hash function + bitmap
  - 哈希碰撞导致的误报(在不一定在)
- LRU cache
  - Hash Table + Double LinkedList
  - 查询: O(1)
  - 插入/删除: O(1)
